name: DVWA CI/CD

on:
  push:
    branches:
      - master

jobs:
  build-and-push-dev:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set_tag.outputs.tag }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Docker login to JFrog Registry
      run: |
        echo "${{ secrets.JFROG_PASSWORD }}" | docker login ${{ secrets.DOCKER_REPO_DEV }} \
          --username ${{ secrets.JFROG_USERNAME }} --password-stdin

    - name: Docker image build
      run: docker build -t dvwa:latest .

    - name: Generate image tag
      run: echo "TAG=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_ENV

    - name: Output image tag
      id: set_tag
      run: echo "tag=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

    - name: Docker tag image
      run: docker tag dvwa:latest ${{ secrets.DOCKER_REPO_DEV }}/docker-dev/dvwa:dev-$TAG

    - name: Push image to JFrog Dev
      run: docker push ${{ secrets.DOCKER_REPO_DEV }}/docker-dev/dvwa:dev-$TAG
    
    - name: Install JFrog CLI
      run: |
        curl -fL https://install-cli.jfrog.io | sh

    - name: Set JFrog CLI auth
      run: |
        echo "JFROG_CLI_JFROG_URL=${{ secrets.JFROG_URL }}" >> $GITHUB_ENV
        echo "JFROG_CLI_JFROG_ACCESS_TOKEN=${{ secrets.JFROG_API_TOKEN }}" >> $GITHUB_ENV

    - name: Debug CLI config
      run: jf config show jfrog-server

    - name: Set build environment variables
      run: |
        echo "BUILD_NAME=dvwa-ci" >> $GITHUB_ENV
        echo "BUILD_NUMBER=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_ENV

    - name: Push Docker image metadata (with build info)
      run: |
        jf rt docker-push ${{ secrets.DOCKER_REPO_DEV }}/docker-dev/dvwa:dev-$TAG docker-dev \
          --build-name=$BUILD_NAME \
          --build-number=$BUILD_NUMBER
    

    - name: Collect environment variables for build
      run: |
        jf rt build-collect-env $BUILD_NAME $BUILD_NUMBER 

    - name: Publish the build info to JFrog Artifactory
      run: |
        jf rt build-publish $BUILD_NAME $BUILD_NUMBER 

    - name: Add Git metadata to the build
      run: |
        jf rt build-add-git $BUILD_NAME $BUILD_NUMBER 

    # --- Evidence Integration Steps (according to official JFrog example) ---

    - name: Generate RSA private/public keys
      run: |
        openssl genrsa -out private.pem 2048
        openssl rsa -in private.pem -pubout -out public.pem

    - name: Upload public key to JFrog Artifactory
      run: |
        curl -u "${{ secrets.JFROG_USERNAME }}:${{ secrets.JFROG_API_TOKEN }}" \
          -X PUT "${{ secrets.JFROG_URL }}/artifactory/api/security/keypair/my-rsa-key?public=true" \
          -H "Content-Type: application/json" \
          -d '{"public_key": "'"$(sed 's/$/\\n/' public.pem | tr -d '\n')"'" }'

    - name: Create SBOM evidence (JSON file)
      run: |
        echo '{"actor":"${{ github.actor }}","date":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'","sbom":"demo-placeholder"}' > sbom.json

    - name: Create and attach signed build evidence (aligned with JFrog's documentation)
      run: |
        jf evd create \
          --build-name="${BUILD_NAME}" \
          --build-number="${BUILD_NUMBER}" \
          --predicate=./sbom.json \
          --predicate-type=https://jfrog.com/evidence/build-signature/v1 \
          --key=private.pem \
        echo 'âœ… Evidence successfully attached to build' >> $GITHUB_STEP_SUMMARY

  # --- Second Job remains unchanged (no edits needed) ---

  test-scan-and-verify:
    needs: build-and-push-dev
    runs-on: ubuntu-latest
    environment:
      name: test

    steps:
    - name: Await manual approval
      run: echo "Test stage approved. Ready to run scans."

    - name: Authenticate to JFrog Docker Registry
      run: |
        echo "${{ secrets.JFROG_PASSWORD }}" | docker login ${{ secrets.DOCKER_REPO_DEV }} \
          --username ${{ secrets.JFROG_USERNAME }} --password-stdin

    - name: Pull dev image
      run: docker pull ${{ secrets.DOCKER_REPO_DEV }}/docker-dev/dvwa:dev-${{ needs.build-and-push-dev.outputs.tag }}

    - name: Run DVWA container
      run: docker run -d -p 8080:80 --name dvwa-test ${{ secrets.DOCKER_REPO_DEV }}/docker-dev/dvwa:dev-${{ needs.build-and-push-dev.outputs.tag }}

    - name: Verify DVWA is running
      run: |
        RUNNING=$(docker inspect -f '{{.State.Running}}' dvwa-test)
        if [ "$RUNNING" != "true" ]; then
          echo "Container not running, logs:"
          docker logs dvwa-test
          exit 1
        fi

    - name: Check exposed ports
      run: docker exec dvwa-test netstat -tulnp || ss -tulnp

    - name: Health check DVWA
      run: |
        for i in {1..10}; do
          STATUS=$(curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:8080)
          if [ "$STATUS" -eq 200 ]; then
            echo "DVWA running properly."
            exit 0
          fi
          echo "Attempt $i: HTTP $STATUS"
          sleep 5
        done
        echo "DVWA didn't start properly, logs:"
        docker logs dvwa-test
        exit 1

    - name: Terminate DVWA container
      run: docker stop dvwa-test
